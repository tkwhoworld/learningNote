## 核心思想：Elasticsearch 是什么？
Elasticsearch 是一个开源的、分布式的、基于 RESTful API 的搜索和分析引擎。它构建在 Apache Lucene 之上，但其核心威力来自于其分布式架构。

## 核心概念（与图书馆类比）
首先，理解这几个核心概念至关重要，它们是与传统数据库（如 MySQL）最大的不同。

传统数据库 (MySQL)	Elasticsearch	图书馆类比
数据库 (Database)	索引 (Index)	一个专题图书馆（如“科技图书馆”）
表 (Table)	类型 (Type) (已在 7.x+ 版本逐渐废弃)	图书馆里的图书分类（如“计算机类”、“物理类”）
行 (Row)	文档 (Document)	一本具体的书
列 (Column)	字段 (Field)	书中的具体信息（如“书名”、“作者”、“正文内容”）
schema	映射 (Mapping)	书的编写规范（规定书名是字符串，页数是数字）
分片 (Shard)	因为一个图书馆的书太多，所以分成多个分馆存放
副本 (Replica)	每个分馆的备份馆，防止分馆失火导致书籍丢失

## 关键点
文档是 ES 中的基本信息单元，以 JSON 格式表示。它不仅是数据，还带有索引、类型和 ID 等元数据。

索引是文档的集合，是进行 CRUD 和搜索操作的主要对象。

分片是实现分布式存储的核心。一个索引可以分成多个分片，分布到不同的服务器上。

主分片 (Primary Shard)：存储数据，数量在索引创建时指定，后期无法修改（除非重建索引）。

副本分片 (Replica Shard)：是主分片的拷贝，提供高可用性和提升读取性能（因为搜索可以在所有副本上并行执行）。数量可以动态调整。

## 二、核心原理：倒排索引 (Inverted Index)
这是 Elasticsearch 实现快速搜索的基石，也是其与传统数据库正排索引的根本区别。

正排索引 (Forward Index)：像一本书的目录。通过 ID（页码）找到内容。

文档 1 -> "I love elasticsearch"

文档 2 -> "I love reading"

倒排索引 (Inverted Index)：像一本书最后的索引页。通过关键词找到它出现在哪些文档（页码）里。

"I" -> [文档1, 文档2]

"love" -> [文档1, 文档2]

"elasticsearch" -> [文档1]

"reading" -> [文档2]

这个过程还包括：

分词 (Analysis)：将文本拆分成一个个独立的词条（Token）。例如 "I love elasticsearch" 会被分成 ["i", "love", "elasticsearch"]。

标准化 (Normalization)：将词条转为小写、去除停用词（a, an, the）、提取词干（"running" -> "run"）等，目的是为了提升搜索命中率。

搜索 "love" 时，ES 直接去倒排索引里找到 "love" -> [文档1, 文档2]，瞬间返回结果。

## 三、分布式架构与工作原理
1. 集群与节点 (Cluster & Node)
一个 ES 集群由多个节点组成。每个节点是一个 ES 实例，承担不同的角色：

Master Node：管理集群状态，如创建/删除索引、跟踪节点状态、决定分片分配。它不处理用户请求。

Data Node：存储数据，执行数据的增、删、改、查和聚合操作。是干活的主力，需要大量的 CPU、内存和 IO。

Coordinating Node：接收客户端请求，将请求转发到正确的数据节点，并将各节点的结果汇总后返回给客户端。所有节点默认都是 Coordinating Node。

2. 写入数据流程
假设我们有一个 3 节点的集群，索引有 2 个主分片，每个主分片有 1 个副本分片。

客户端发送一个写入请求到 Coordinating Node (协调节点)。

协调节点通过文档 ID 路由（默认 _id 的哈希值）确定该文档应该属于哪个分片（比如 P1）。

协调节点将请求转发给 P1 主分片所在的数据节点。

该数据节点在 P1 主分片上执行写入操作（写入索引和事务日志）。

写入成功后，该节点并行地将请求转发给 P1 的两个副本分片所在的数据节点。

所有副本分片都报告成功后，P1 主分片所在节点向协调节点报告成功。

协调节点最终将成功结果返回给客户端。

特点： 为了保证数据一致性，ES 默认使用主备模型，写操作必须在主分片和所有副本分片都成功后才返回。

(这是一个简化的示意图，展示了数据如何从客户端通过协调节点写入主分片，再同步到副本分片的过程)

3. 搜索数据流程
客户端发送搜索请求到 Coordinating Node。

协调节点将请求广播到索引的每一个分片（包括主分片和副本分片）。

每个分片本地执行查询（在自己的倒排索引中查找），并创建一个优先级队列存储匹配的文档（包含评分和 ID），返回给协调节点。

协调节点合并、排序所有分片返回的结果，生成一个全局排序列表。

协调节点根据需要，再去相关分片上获取（Fetch） 完整文档数据。

协调节点将最终结果返回给客户端。

特点： 搜索是并行执行的，极大地提升了效率。

## 1. 集群与节点 (Cluster & Node)
一个 ES 集群由多个节点组成。每个节点是一个 ES 实例，承担不同的角色：

Master Node：管理集群状态，如创建/删除索引、跟踪节点状态、决定分片分配。它不处理用户请求。

Data Node：存储数据，执行数据的增、删、改、查和聚合操作。是干活的主力，需要大量的 CPU、内存和 IO。

Coordinating Node：接收客户端请求，将请求转发到正确的数据节点，并将各节点的结果汇总后返回给客户端。所有节点默认都是 Coordinating Node。

2. 写入数据流程
假设我们有一个 3 节点的集群，索引有 2 个主分片，每个主分片有 1 个副本分片。

客户端发送一个写入请求到 Coordinating Node (协调节点)。

协调节点通过文档 ID 路由（默认 _id 的哈希值）确定该文档应该属于哪个分片（比如 P1）。

协调节点将请求转发给 P1 主分片所在的数据节点。

该数据节点在 P1 主分片上执行写入操作（写入索引和事务日志）。

写入成功后，该节点并行地将请求转发给 P1 的两个副本分片所在的数据节点。

所有副本分片都报告成功后，P1 主分片所在节点向协调节点报告成功。

协调节点最终将成功结果返回给客户端。

特点： 为了保证数据一致性，ES 默认使用主备模型，写操作必须在主分片和所有副本分片都成功后才返回。

(这是一个简化的示意图，展示了数据如何从客户端通过协调节点写入主分片，再同步到副本分片的过程)

3. 搜索数据流程
客户端发送搜索请求到 Coordinating Node。

协调节点将请求广播到索引的每一个分片（包括主分片和副本分片）。

每个分片本地执行查询（在自己的倒排索引中查找），并创建一个优先级队列存储匹配的文档（包含评分和 ID），返回给协调节点。

协调节点合并、排序所有分片返回的结果，生成一个全局排序列表。

协调节点根据需要，再去相关分片上获取（Fetch） 完整文档数据。

协调节点将最终结果返回给客户端。

特点： 搜索是并行执行的，极大地提升了效率。